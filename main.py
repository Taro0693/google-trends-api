from flask import Flask, request, jsonify
import time
import random
import logging
import os
import threading
from datetime import datetime, timedelta

# „É≠„Ç∞Ë®≠ÂÆö
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# ÊÆµÈöéÁöÑ„Ç§„É≥„Éù„Éº„Éà
PANDAS_AVAILABLE = False
PYTRENDS_AVAILABLE = False

try:
    import pandas as pd
    PANDAS_AVAILABLE = True
    logger.info("‚úÖ Pandas imported successfully")
except Exception as e:
    logger.error(f"‚ùå Pandas import failed: {e}")

try:
    from pytrends.request import TrendReq
    PYTRENDS_AVAILABLE = True
    logger.info("‚úÖ Pytrends imported successfully")
except Exception as e:
    logger.error(f"‚ùå Pytrends import failed: {e}")

# RenderÊúÄÈÅ©Âåñ: Keep-AliveÊ©üËÉΩ
class KeepAlive:
    def __init__(self):
        self.last_request = datetime.now()
        self.is_running = True
        
    def update_last_request(self):
        self.last_request = datetime.now()
        
    def start_keep_alive(self):
        """Keep-Alive„Çπ„É¨„ÉÉ„Éâ„ÇíÈñãÂßã"""
        def keep_alive_worker():
            while self.is_running:
                try:
                    # 10ÂàÜÈñìÈöî„Åßping„ÇíÈÄÅ‰ø°
                    time.sleep(600)
                    if (datetime.now() - self.last_request).seconds > 600:
                        logger.info("üîÑ Keep-alive ping - server is alive")
                        
                except Exception as e:
                    logger.error(f"Keep-alive error: {e}")
                    
        thread = threading.Thread(target=keep_alive_worker, daemon=True)
        thread.start()
        logger.info("üöÄ Keep-alive service started")

# Keep-Alive„Ç§„É≥„Çπ„Çø„É≥„Çπ
keep_alive = KeepAlive()

@app.before_request
def before_request():
    """„É™„ÇØ„Ç®„Çπ„ÉàÂâçÂá¶ÁêÜ - Keep-AliveÊõ¥Êñ∞"""
    keep_alive.update_last_request()

@app.route("/")
def home():
    status = {
        "service": "Google Trends API for Smart GAS (Render Optimized)",
        "pandas": "‚úÖ Available" if PANDAS_AVAILABLE else "‚ùå Not Available",
        "pytrends": "‚úÖ Available" if PYTRENDS_AVAILABLE else "‚ùå Not Available",
        "version": "2.1.0 (Render Enhanced)",
        "timestamp": datetime.now().isoformat(),
        "uptime": str(datetime.now() - keep_alive.last_request),
        "environment": "Render" if os.getenv('RENDER') else "Local"
    }
    
    logger.info(f"Home endpoint accessed - Libraries OK: {PANDAS_AVAILABLE and PYTRENDS_AVAILABLE}")
    return jsonify(status)

@app.route("/health")
def health_check():
    """„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºàRenderÊúÄÈÅ©ÂåñÔºâ"""
    health_status = {
        "status": "healthy" if PANDAS_AVAILABLE and PYTRENDS_AVAILABLE else "degraded",
        "libraries": {
            "pandas": PANDAS_AVAILABLE,
            "pytrends": PYTRENDS_AVAILABLE
        },
        "timestamp": datetime.now().isoformat(),
        "server_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC"),
        "last_request": keep_alive.last_request.isoformat(),
        "render_optimizations": {
            "keep_alive": True,
            "cold_start_protection": True,
            "enhanced_retry": True
        }
    }
    
    # „É©„Ç§„Éñ„É©„É™Áä∂ÊÖã„Å´„Çà„ÇãÈÅ©Âàá„Å™„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ
    status_code = 200 if PANDAS_AVAILABLE and PYTRENDS_AVAILABLE else 503
    
    logger.info(f"Health check - Status: {health_status['status']}")
    return jsonify(health_status), status_code

@app.route("/ping")
def ping():
    """ËªΩÈáè„Å™ping„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºàKeep-AliveÁî®Ôºâ"""
    return jsonify({
        "pong": True,
        "timestamp": datetime.now().isoformat()
    })

@app.route("/warmup", methods=["GET", "POST"])
def warmup():
    """„Ç¶„Ç©„Éº„É†„Ç¢„ÉÉ„ÉóÂ∞ÇÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà"""
    logger.info("üî• Warmup endpoint called")
    
    warmup_result = {
        "warmed_up": True,
        "timestamp": datetime.now().isoformat(),
        "libraries_ready": PANDAS_AVAILABLE and PYTRENDS_AVAILABLE,
        "server_ready": True
    }
    
    # „É©„Ç§„Éñ„É©„É™„ÅÆÂãï‰Ωú„ÉÜ„Çπ„Éà
    if PANDAS_AVAILABLE and PYTRENDS_AVAILABLE:
        try:
            # ËªΩÈáè„Å™„ÉÜ„Çπ„ÉàÂÆüË°å
            test_trends = TrendReq(hl="ja-JP", tz=540, timeout=(5, 10))
            warmup_result["pytrends_test"] = "‚úÖ OK"
            logger.info("‚úÖ Pytrends warmup test successful")
        except Exception as e:
            warmup_result["pytrends_test"] = f"‚ùå {str(e)}"
            logger.warning(f"‚ö†Ô∏è Pytrends warmup test failed: {e}")
    
    return jsonify(warmup_result)

@app.route("/trend", methods=["POST"])
def trend():
    # „É©„Ç§„Éñ„É©„É™ÂèØÁî®ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
    if not PANDAS_AVAILABLE or not PYTRENDS_AVAILABLE:
        logger.error("‚ùå Required libraries not available")
        return jsonify({
            "error": "Required libraries not available",
            "details": {
                "pandas": PANDAS_AVAILABLE,
                "pytrends": PYTRENDS_AVAILABLE
            },
            "solution": "Server is starting up. Please try the /warmup endpoint first."
        }), 503
    
    try:
        # „É™„ÇØ„Ç®„Çπ„Éà„Éá„Éº„Çø„ÅÆÂèñÂæó„Å®Ê§úË®º
        data = request.json
        if not data:
            return jsonify({"error": "No JSON data provided"}), 400
        
        validation_result = validate_request(data)
        if not validation_result["valid"]:
            return jsonify({"error": validation_result["message"]}), 400
        
        keywords = data.get("keywords", [])
        timeframe = data.get("timeframe", "today 12-m")
        frequency = data.get("frequency", "weekly")
        geo = data.get("geo", "JP")
        
        logger.info(f"üöÄ Processing request: {len(keywords)} keywords, {frequency} frequency, geo: {geo}")
        
        # RenderÊúÄÈÅ©Âåñ: Âá¶ÁêÜÈñãÂßã„É≠„Ç∞
        start_time = time.time()
        
        # Google Trends„Éá„Éº„ÇøÂèñÂæó
        result = fetch_trends_with_render_optimization(keywords, timeframe, frequency, geo)
        
        # Âá¶ÁêÜÊôÇÈñì„É≠„Ç∞
        processing_time = time.time() - start_time
        logger.info(f"‚è±Ô∏è Processing completed in {processing_time:.2f} seconds")
        
        if "error" in result:
            return jsonify(result), 429 if "rate limit" in result["error"].lower() else 500
        
        # ÊàêÂäüÊôÇ„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Å´ËøΩÂä†ÊÉÖÂ†±
        result["meta"] = {
            "processing_time_seconds": round(processing_time, 2),
            "server_timestamp": datetime.now().isoformat(),
            "keywords_processed": len(keywords),
            "data_points": len(result.get("data", []))
        }
        
        logger.info(f"‚úÖ Successfully processed {len(keywords)} keywords")
        return jsonify(result)
        
    except Exception as e:
        error_msg = str(e)
        logger.error(f"üí• Unexpected error: {error_msg}")
        return jsonify({
            "error": "Internal server error",
            "details": error_msg,
            "timestamp": datetime.now().isoformat()
        }), 500

def validate_request(data):
    """„É™„ÇØ„Ç®„Çπ„Éà„Éá„Éº„Çø„ÅÆË©≥Á¥∞Ê§úË®ºÔºàRenderÊúÄÈÅ©ÂåñÔºâ"""
    keywords = data.get("keywords", [])
    
    # „Ç≠„Éº„ÉØ„Éº„ÉâÊ§úË®º
    if not keywords:
        return {"valid": False, "message": "Keywords are required"}
    
    if not isinstance(keywords, list):
        return {"valid": False, "message": "Keywords must be a list"}
    
    if len(keywords) > 4:
        return {"valid": False, "message": "Maximum 4 keywords allowed (Google Trends API limitation)"}
    
    # Á©∫„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    valid_keywords = [k for k in keywords if k and str(k).strip()]
    if len(valid_keywords) != len(keywords):
        return {"valid": False, "message": "Empty keywords are not allowed"}
    
    # „Ç≠„Éº„ÉØ„Éº„ÉâÈï∑„ÉÅ„Çß„ÉÉ„ÇØÔºàRenderÊúÄÈÅ©ÂåñÔºâ
    for keyword in keywords:
        if len(str(keyword).strip()) > 100:
            return {"valid": False, "message": "Keywords must be less than 100 characters"}
    
    # ÊúüÈñìÊ§úË®º
    frequency = data.get("frequency", "weekly").lower()
    valid_frequencies = ["daily", "weekly", "monthly"]
    if frequency not in valid_frequencies:
        return {"valid": False, "message": f"Frequency must be one of: {valid_frequencies}"}
    
    # „Çø„Ç§„É†„Éï„É¨„Éº„É†Ê§úË®º
    timeframe = data.get("timeframe", "")
    if timeframe and not validate_timeframe(timeframe, frequency):
        return {"valid": False, "message": "Invalid timeframe for specified frequency"}
    
    return {"valid": True}

def validate_timeframe(timeframe, frequency):
    """„Çø„Ç§„É†„Éï„É¨„Éº„É†„Å®ÊúüÈñì„ÅÆÊï¥ÂêàÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
    try:
        if " " in timeframe:
            start_str, end_str = timeframe.split(" ", 1)
            start_date = datetime.strptime(start_str, "%Y-%m-%d")
            end_date = datetime.strptime(end_str, "%Y-%m-%d")
            
            days_diff = (end_date - start_date).days
            
            # Google Trends„ÅÆÂà∂Á¥Ñ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            if frequency == "daily" and days_diff > 270:
                return False
            elif frequency == "weekly" and days_diff < 7:
                return False
            elif frequency == "monthly" and days_diff < 30:
                return False
                
        return True
    except:
        return True

def fetch_trends_with_render_optimization(keywords, timeframe, frequency, geo):
    """RenderÊúÄÈÅ©ÂåñÁâà„Éá„Éº„ÇøÂèñÂæó"""
    max_retries = 4  # RenderÁî®„Å´Â¢óÂä†
    base_delay = 8   # RenderÁî®„Å´Âª∂Èï∑
    
    for attempt in range(max_retries):
        try:
            logger.info(f"üîÑ Attempt {attempt + 1}/{max_retries} for keywords: {keywords}")
            
            # Ë©¶Ë°åÈñì„ÅÆÂæÖÊ©üÔºàRenderÊúÄÈÅ©ÂåñÔºâ
            if attempt > 0:
                wait_time = base_delay * (2 ** (attempt - 1)) + random.uniform(3, 12)
                logger.info(f"‚è≥ Waiting {wait_time:.1f} seconds before retry...")
                time.sleep(wait_time)
            
            # ÂàùÊúü„É©„É≥„ÉÄ„É†ÈÅÖÂª∂ÔºàCold startÂØæÁ≠ñÔºâ
            initial_delay = random.uniform(2, 6) if attempt == 0 else random.uniform(1, 3)
            logger.info(f"‚è≥ Initial delay: {initial_delay:.1f} seconds")
            time.sleep(initial_delay)
            
            # pytrends „Ç§„É≥„Çπ„Çø„É≥„Çπ‰ΩúÊàêÔºàRenderÊúÄÈÅ©ÂåñÔºâ
            pytrends = TrendReq(
                hl="ja-JP", 
                tz=540,
                timeout=(15, 30),  # RenderÁî®„Å´„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÂª∂Èï∑
                retries=3,         # ÂÜÖÈÉ®„É™„Éà„É©„Ç§Â¢óÂä†
                backoff_factor=0.2 # „Éê„ÉÉ„ÇØ„Ç™„Éï‰øÇÊï∞Ë™øÊï¥
            )
            
            # „Éö„Ç§„É≠„Éº„ÉâÊßãÁØâ
            build_payload_safely(pytrends, keywords, timeframe, geo)
            
            # „Éá„Éº„ÇøÂèñÂæó
            logger.info("üìä Fetching data from Google Trends...")
            df = pytrends.interest_over_time()
            
            if df.empty:
                if attempt == max_retries - 1:
                    logger.warning("üì≠ No data available after all retries")
                    return {"error": "No data available from Google Trends after all retries"}
                logger.warning(f"üì≠ Empty data on attempt {attempt + 1}, retrying...")
                continue
            
            # „Éá„Éº„ÇøÂá¶ÁêÜ
            logger.info("üîß Processing data...")
            processed_data = process_trends_dataframe(df, frequency)
            
            logger.info(f"‚úÖ Success on attempt {attempt + 1}")
            return {"data": processed_data}
            
        except Exception as e:
            error_msg = str(e)
            logger.error(f"‚ùå Attempt {attempt + 1} failed: {error_msg}")
            
            # Rate limit„Ç®„É©„Éº„ÅÆÁâπÂà•Âá¶ÁêÜÔºàRenderÊúÄÈÅ©ÂåñÔºâ
            if any(keyword in error_msg.lower() for keyword in ["429", "rate limit", "too many requests"]):
                if attempt < max_retries - 1:
                    long_wait = 90 + random.uniform(30, 60)  # 2-2.5ÂàÜ
                    logger.info(f"üö´ Rate limit detected, waiting {long_wait:.1f} seconds...")
                    time.sleep(long_wait)
                    continue
                else:
                    return {"error": "Rate limit exceeded. Please try again later.", "retry_after": 300}
            
            # „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Ç®„É©„Éº„ÅÆÂá¶ÁêÜ
            if "timeout" in error_msg.lower():
                if attempt < max_retries - 1:
                    timeout_wait = 30 + random.uniform(10, 30)
                    logger.info(f"‚è∞ Timeout detected, waiting {timeout_wait:.1f} seconds...")
                    time.sleep(timeout_wait)
                    continue
            
            # „Åù„ÅÆ‰ªñ„ÅÆ„Ç®„É©„Éº
            if attempt == max_retries - 1:
                return {"error": f"Failed after {max_retries} attempts: {error_msg}"}
    
    return {"error": "Unknown error occurred"}

def build_payload_safely(pytrends, keywords, timeframe, geo):
    """ÂÆâÂÖ®„Å™„Éö„Ç§„É≠„Éº„ÉâÊßãÁØâÔºàRenderÊúÄÈÅ©ÂåñÔºâ"""
    try:
        logger.info(f"üîß Building payload for keywords: {keywords}")
        
        # Âü∫Êú¨ÁöÑ„Å™„Éö„Ç§„É≠„Éº„ÉâÊßãÁØâ
        if geo and geo.strip() and geo.upper() != "NONE":
            pytrends.build_payload(
                kw_list=keywords,
                timeframe=timeframe,
                geo=geo.upper()
            )
        else:
            pytrends.build_payload(
                kw_list=keywords,
                timeframe=timeframe
            )
            
        logger.info("‚úÖ Payload built successfully")
        
    except Exception as e:
        logger.error(f"‚ùå Payload build error: {e}")
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Çà„ÇäÂü∫Êú¨ÁöÑ„Å™„Éö„Ç§„É≠„Éº„Éâ
        try:
            pytrends.build_payload(kw_list=keywords)
            logger.info("‚úÖ Fallback payload built")
        except Exception as fallback_error:
            logger.error(f"‚ùå Fallback payload failed: {fallback_error}")
            raise e

def process_trends_dataframe(df, frequency):
    """„Éá„Éº„Çø„Éï„É¨„Éº„É†Âá¶ÁêÜÔºàRenderÊúÄÈÅ©ÂåñÁâàÔºâ"""
    try:
        logger.info(f"üìä Processing DataFrame: {df.shape}")
        
        # isPartialÂàó„ÅÆÂâäÈô§
        if 'isPartial' in df.columns:
            df = df.drop(columns=['isPartial'])
            logger.info("üóëÔ∏è Removed isPartial column")
        
        # ÊúüÈñìÂ§âÊèõ
        if frequency == "daily":
            df = convert_to_daily_safe(df)
        elif frequency == "monthly":
            df = convert_to_monthly_safe(df)
        # weekly„ÅØ„Åù„ÅÆ„Åæ„ÅæÔºà„Éá„Éï„Ç©„É´„ÉàÔºâ
        
        # „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂàó„Å´Â§âÊèõ
        df_result = df.reset_index()
        
        # Êó•‰ªòÂàó„ÅÆÂá¶ÁêÜ
        date_column = find_date_column(df_result)
        if date_column and date_column != 'date':
            df_result = df_result.rename(columns={date_column: 'date'})
            logger.info(f"üìÖ Renamed date column: {date_column} -> date")
        
        # Êó•‰ªò„Éï„Ç©„Éº„Éû„ÉÉ„Éà
        if 'date' in df_result.columns:
            df_result['date'] = format_dates_safely(df_result['date'])
        
        # NaNÂÄ§„Çí0„ÅßÁΩÆÊèõ
        df_result = df_result.fillna(0)
        
        # Êï¥Êï∞Âûã„Å´Â§âÊèõÔºàtrendÂÄ§Ôºâ
        for col in df_result.columns:
            if col != 'date':
                df_result[col] = df_result[col].astype(int)
        
        # ËæûÊõ∏ÂΩ¢Âºè„ÅßËøîÂç¥
        records = df_result.to_dict(orient="records")
        
        logger.info(f"‚úÖ Processed {len(records)} records with {len(df_result.columns)} columns")
        return records
        
    except Exception as e:
        logger.error(f"‚ùå DataFrame processing error: {e}")
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÊúÄÂ∞èÈôê„ÅÆÂá¶ÁêÜ
        try:
            df_simple = df.reset_index().fillna(0)
            simple_records = df_simple.to_dict(orient="records")
            logger.info(f"‚ö†Ô∏è Fallback processing: {len(simple_records)} records")
            return simple_records
        except:
            raise Exception(f"Data processing failed completely: {e}")

def convert_to_daily_safe(df):
    """ÂÆâÂÖ®„Å™Êó•Ê¨°Â§âÊèõ"""
    try:
        if not isinstance(df.index, pd.DatetimeIndex):
            return df
        
        start_date = df.index.min()
        end_date = df.index.max()
        daily_index = pd.date_range(start=start_date, end=end_date, freq='D')
        
        df_reindexed = df.reindex(df.index.union(daily_index))
        df_interpolated = df_reindexed.interpolate(method='linear')
        df_daily = df_interpolated.reindex(daily_index)
        
        logger.info(f"üìÖ Converted to daily: {len(df_daily)} days")
        return df_daily
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Daily conversion failed: {e}, returning original data")
        return df

def convert_to_monthly_safe(df):
    """ÂÆâÂÖ®„Å™ÊúàÊ¨°Â§âÊèõ"""
    try:
        if not isinstance(df.index, pd.DatetimeIndex):
            return df
        
        df_monthly = df.resample('M').mean()
        df_monthly.index = df_monthly.index.to_period('M').to_timestamp()
        
        logger.info(f"üìÖ Converted to monthly: {len(df_monthly)} months")
        return df_monthly
        
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Monthly conversion failed: {e}, returning original data")
        return df

def find_date_column(df):
    """Êó•‰ªòÂàó„ÇíÁâπÂÆö"""
    for col in df.columns:
        if any(word in col.lower() for word in ['date', 'time', 'index']):
            return col
        
        try:
            if pd.api.types.is_datetime64_any_dtype(df[col]):
                return col
        except:
            continue
    
    return None

def format_dates_safely(date_series):
    """ÂÆâÂÖ®„Å™Êó•‰ªò„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
    try:
        date_series = pd.to_datetime(date_series)
        return date_series.dt.strftime('%Y-%m-%d')
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Date formatting failed: {e}, returning original")
        return date_series

# Render„Å´ÊúÄÈÅ©Âåñ„Åï„Çå„Åü„Ç®„É©„Éº„Éè„É≥„Éâ„É©„Éº
@app.errorhandler(404)
def not_found(error):
    return jsonify({
        "error": "Endpoint not found",
        "available_endpoints": ["/", "/health", "/ping", "/warmup", "/trend"],
        "timestamp": datetime.now().isoformat()
    }), 404

@app.errorhandler(405)
def method_not_allowed(error):
    return jsonify({
        "error": "Method not allowed",
        "hint": "Use POST for /trend endpoint",
        "timestamp": datetime.now().isoformat()
    }), 405

@app.errorhandler(500)
def internal_error(error):
    logger.error(f"üí• Internal server error: {error}")
    return jsonify({
        "error": "Internal server error",
        "libraries_status": {
            "pandas": PANDAS_AVAILABLE,
            "pytrends": PYTRENDS_AVAILABLE
        },
        "timestamp": datetime.now().isoformat()
    }), 500

if __name__ == "__main__":
    logger.info("üöÄ Starting Google Trends API server (Render optimized version)...")
    
    # Keep-Alive„Çµ„Éº„Éì„ÇπÈñãÂßã
    keep_alive.start_keep_alive()
    
    # Render„ÅÆÂ†¥Âêà„ÅØ„Éù„Éº„ÉàË®≠ÂÆö
    port = int(os.environ.get("PORT", 10000))
    
    logger.info(f"üåê Server starting on port {port}")
    app.run(host="0.0.0.0", port=port, debug=False)
